# Cuda 代码解析

这段 C++ 代码使用了 CUDA 进行数据的复制操作，分别实现了非合并访问和合并访问的两种方式，并对两种方式进行性能对比。

## 一、函数定义

1. `copyDataNonCoalesced`函数：
   - **功能**：这个 CUDA 内核函数实现了非合并访问的数据复制。每个线程从输入数组`in`中以非连续的方式读取数据，然后写入到输出数组`out`中。具体来说，输出数组`out`的第`index`个元素来自输入数组`in`的`(index * 2) % n`位置。
   - **参数**：
     - `float *in`：输入数组的指针。
     - `float *out`：输出数组的指针。
     - `int n`：数组的长度。
   - **执行条件**：只有当线程索引`index`小于数组长度`n`时，才进行数据复制操作。

2. `copyDataCoalesced`函数：
   - **功能**：这个 CUDA 内核函数实现了合并访问的数据复制。每个线程从输入数组`in`中以连续的方式读取数据，然后写入到输出数组`out`中。即输出数组`out`的第`index`个元素直接来自输入数组`in`的第`index`个位置。
   - **参数**：
     - `float *in`：输入数组的指针。
     - `float *out`：输出数组的指针。
     - `int n`：数组的长度。
   - **执行条件**：只有当线程索引`index`小于数组长度`n`时，才进行数据复制操作。

3. `initializeArray`函数：
   - **功能**：用于初始化给定的数组。将数组中的每个元素设置为其索引值。
   - **参数**：
     - `float *arr`：要初始化的数组指针。
     - `int n`：数组的长度。

## 二、主函数`main`

1. **变量初始化**：
   - 定义了数组长度`n`为`1 << 24`，表示数组的大小为$2^{24}$。这个值可以根据需要进行调整以增加或减小工作量。
   - 定义了两个指针`in`和`out`，分别用于指向输入和输出数组。

2. **内存分配**：
   - 使用`cudaMallocManaged`函数在统一内存空间中分配了输入数组`in`和输出数组`out`的内存空间，大小均为`n * sizeof(float)`。

3. **数组初始化**：
   - 调用`initializeArray`函数初始化输入数组`in`，将其每个元素设置为其索引值。

4. **非合并访问数据复制**：
   - 定义了线程块大小`blockSize`为 128。可以根据需要调整这个值，不同的块大小可能会影响性能。
   - 计算需要的线程块数量`numBlocks`，确保有足够的线程块来覆盖整个数组。计算公式为`(n + blockSize - 1) / blockSize`。
   - 使用`copyDataNonCoalesced<<<numBlocks, blockSize>>>(in, out, n)`启动非合并访问的 CUDA 内核函数，将输入数组`in`中的数据以非合并访问的方式复制到输出数组`out`中。
   - 使用`cudaDeviceSynchronize`函数等待 GPU 上的所有任务完成。

5. **重置输出数组并进行合并访问数据复制**：
   - 再次调用`initializeArray(out, n)`重置输出数组，以便进行下一次数据复制操作。
   - 使用`copyDataCoalesced<<<numBlocks, blockSize>>>(in, out, n)`启动合并访问的 CUDA 内核函数，将输入数组`in`中的数据以合并访问的方式复制到输出数组`out`中。
   - 使用`cudaDeviceSynchronize`函数等待 GPU 上的所有任务完成。

6. **内存释放**：
   - 使用`cudaFree`函数释放输入数组`in`和输出数组`out`所占用的内存空间。

7. **返回值**：
   - 主函数返回 0，表示程序正常结束。